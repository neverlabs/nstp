# NSTP-v1: Neverlabs Secure Transport Protocol

**Version:** 1.0
**Status:** Draft Standard
**Date:** 2025-11-16
**Editors:** Neverlabs

---

# 1. Introduction

NSTP (Neverlabs Secure Transport Protocol) is a lightweight, PSK-based secure transport protocol designed for constrained IoT devices communicating over TCP, BLE, or other stream-oriented channels.

NSTP provides:

* Mutual authentication based on username + password
* Strong offline password hardening
* Session key derivation
* Confidentiality and integrity using AES-GCM
* Replay protection using per-session monotonically increasing counters
* Simplicity suitable for microcontrollers such as ESP32

NSTP is **not intended to replace TLS/DTLS**, but to offer a much simpler alternative when:

* Certificates are not desired
* BLE or serial channels are used
* Full TLS stacks are too heavy
* Only PSK-based authentication is required

---

# 2. Terminology

**MUST / MUST NOT, SHOULD / SHOULD NOT, MAY**
Meanings follow RFC 2119.

**Device Salt**
A per-device 8–16 byte static non-secret value used in PBKDF2.

**Username**
Identifier of a user or application.

**Password**
Secret known to both client and server (never transmitted).

**PSK**
A pre-shared key derived from password, username, and device salt.

**Session Nonce**
12-byte random value generated by the server and used as AES-GCM nonce prefix for the entire session.

**Counter**
A monotonically increasing 32-bit message counter used to prevent replay.

**Session Key**
32-byte AES key derived from PBKDF2 result.

**Ciphertext**
AES-GCM encrypted message with authentication tag appended.

---

# 3. Protocol Overview

NSTP consists of two phases:

1. **Handshake Phase**

   * Client sends username/password
   * Server derives PSK via PBKDF2
   * Server generates session nonce
   * Both compute session key
   * Secure channel established

2. **Secure Transport Phase**

   * Messages protected with AES-GCM
   * Replay protection enforced via message counter

The protocol requires **no server-side user state**, except password storage and per-session counters.

---

# 4. Cryptographic Algorithms

NSTP v1 uses the following algorithms:

| Purpose              | Algorithm          | Notes                        |
| -------------------- | ------------------ | ---------------------------- |
| Password stretching  | PBKDF2-HMAC-SHA256 | 600,000 iterations (minimum) |
| Authentication       | HMAC-SHA256        | Tag length: 32 bytes         |
| Symmetric encryption | AES-128-GCM        | 12-byte nonce                |
| Replay protection    | 32-bit BE counter  | Included outside AES-GCM     |
| RNG                  | CSPRNG             | Required for session nonces  |

**All MUST be implemented exactly as specified.**

---

# 5. PSK Derivation

The PSK (pre-shared key) is derived using PBKDF2:

```
PSK = PBKDF2(
    password = UTF8(PASSWORD),
    salt     = device_salt || UTF8(USERNAME),
    iterations = 600000,
    dkLen = 32,
    PRF = HMAC-SHA256
)
```

Requirements:

* Iterations MUST be ≥ 600,000
* device_salt MUST be unique per device
* device_salt MAY be public
* PSK MUST NOT be stored in plaintext

---

# 6. Handshake

The handshake establishes:

* Session key
* Session nonce
* Initial replay counter state

### 6.1 Client → Server: Username

```
0: USERNAME_LEN (1 byte)
1..N: USERNAME (UTF-8)
```

Username length MUST be ≤ 255.

### 6.2 Client → Server: Password

```
0: PASSWORD_LEN (1 byte)
1..N: PASSWORD (UTF-8)
```

Password is never stored or transmitted after handshake.

### 6.3 Server: Session Nonce

Server generates a **12-byte random** session nonce:

```
SESSION_NONCE = random(12)
```

and sends it to the client:

```
0..11: SESSION_NONCE
```

### 6.4 Session Key Derivation

Both sides compute:

```
SESSION_KEY = PBKDF2(password, device_salt + username)
```

(following section 5)

### 6.5 Initialize Replay Protection

Client:

```
counter = 0
```

Server:

```
lastCounter = -1
```

### 6.6 Secure Channel Active

Handshake is complete when the client receives SESSION_NONCE.

---

# 7. Secure Message Format

NSTP messages are of the form:

```
0..3: COUNTER (uint32 BE)
4..N: CIPHERTEXT (AES-GCM output including tag)
```

### 7.1 AES-GCM Nonce

NSTP uses the server’s session nonce directly:

```
AES_NONCE = SESSION_NONCE (12 bytes)
```

The counter is **NOT** inside the AEAD nonce.
Replay protection is handled separately.

### 7.2 Encryption

```
ciphertext = AES-GCM-Encrypt(
    key  = SESSION_KEY,
    nonce = SESSION_NONCE,
    plaintext = message,
    aad = COUNTER
)
```

**AAD MUST include the counter** to bind it cryptographically.

### 7.3 Replay Protection

Server MUST:

* Reject messages where `COUNTER <= lastCounter`
* Update `lastCounter = COUNTER` only on successful AES-GCM verification

Client MUST:

* Increment counter monotonically (`counter++`)

---

# 8. Decryption Errors

Server MUST reject and close session upon:

* AES-GCM tag failure
* Counter replay (`<= lastCounter`)
* Incorrect message structure
* Unexpected input

Optionally:
Server MAY send an error code before closing.

---

# 9. Security Considerations

### 9.1 Password Strength

Although PBKDF2 600k reduces cracking speed, weak passwords MUST be avoided.

### 9.2 Device Salt Disclosure

Device salt is non-secret.
Its purpose is *cross-device key separation*.

### 9.3 Replay Attacks

Prevented by monotonic counters.

### 9.4 Nonce Reuse

SESSION_NONCE MUST be random per connection.
Reusing a nonce with AES-GCM is catastrophically insecure.

### 9.5 Timing Attacks

All MAC/key comparisons MUST use constant-time functions.

---

# 10. Extensibility

Future NSTP versions may add:

* ECDH key exchange
* Session resumption
* Larger nonces
* Larger counters
* Datagram transport mode

All extensions MUST begin with a new NSTP version marker.

---

# 11. Reference Implementations

Directory layout:

```
/reference/dart/client.dart
/reference/dart/server.dart
/reference/dart/crypto_utils.dart
/reference/test_vectors/
```

Dart implementation is the canonical NSTP-v1 reference.

---

# 12. Compliance

An implementation is NSTP-v1 compliant if:

* It implements the handshake
* It derives session keys as specified
* It uses AES-GCM with 12-byte nonce
* It enforces replay protection
* It uses PBKDF2-HMAC-SHA256 with ≥ 600,000 iterations
* It uses constant-time comparisons
* It follows all MUST requirements in this document

---

# 13. IANA Considerations

NSTP does not require IANA registration.

---

# 14. References

RFC 2119 – Key words for use in RFCs
RFC 5869 – HKDF
NIST SP 800-38D – GCM mode
